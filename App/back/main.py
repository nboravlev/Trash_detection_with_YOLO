# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mWDLF51FIfjFlkL4mpM2VJI6j3eqZCw0
"""

from fastapi import FastAPI, File, UploadFile, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
import uvicorn
import shutil
import os
import uuid
from pathlib import Path
from typing import List, Dict, Any
import io
import numpy as np
from PIL import Image
import time


# Import Ultralytics
try:
    from ultralytics import YOLO
except ImportError:
    raise ImportError("Ultralytics not installed. Install with: pip install ultralytics")

# Create FastAPI app
app = FastAPI(title="YOLO Image Detection API")

# Add CORS middleware to allow cross-origin requests from the frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with your frontend URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Create directories if they don't exist
UPLOAD_DIR = Path("./uploads")
UPLOAD_DIR.mkdir(exist_ok=True)

RESULTS_DIR = Path("./results")
RESULTS_DIR.mkdir(exist_ok=True)

MODEL_DIR = Path("./models")
MODEL_DIR.mkdir(exist_ok=True)

# Path to model weights - update this with your actual path
MODEL_PATH = MODEL_DIR / "best.pt"

class YOLODetectionModel:
    def __init__(self, model_path: str):
        """
        Initialize the YOLO model with the specified weights
        """
        print(f"Initializing YOLO model from {model_path}...")
        if not os.path.exists(model_path):
            raise FileNotFoundError(f"Model file not found at {model_path}")

        # Load the YOLO model
        self.model = YOLO(model_path)
        print("Model loaded successfully!")
        
        
    def get_bbox_area(self, bbox):
        x1, y1, x2, y2 = bbox
        return max(0, x2 - x1) * max(0, y2 - y1)

    def get_centroid(self, bbox):
        x1, y1, x2, y2 = bbox
        return ((x1 + x2) // 2, (y1 + y2) // 2)

    def get_bottom_center(self, bbox):
        x1, y1, x2, y2 = bbox
        return ((x1 + x2) // 2, y2)

    def is_point_inside_bbox(self, point, bbox):
        x, y = point
        x1, y1, x2, y2 = bbox
        return x1 <= x <= x2 and y1 <= y <= y2

    def is_point_outside_bbox(self, point, bbox):
        x, y = point
        x1, y1, x2, y2 = bbox

        # Точка считается вне, если:
        # - по горизонтали она слева или справа от бокса
        # - или по вертикали она ниже нижней границы бокса
        if x < x1 or x > x2:
            return True
        if y > y2:
            return True
        return False

    def evaluate_bin_fill(self, detections, fill_threshold=0.3):
        bins = [d for d in detections if d['label'].startswith('bin')]
        trashes = [d for d in detections if d['label'].startswith('trash')]

        bin_statuses = []
        outside_trash = []

        
        if not bins:
            print("⚠️ No bins detected.")
            #return []
     
        for bin_item in bins:
            bin_bbox = bin_item['bbox']
            bin_area = self.get_bbox_area(bin_bbox)
            total_trash_area = 0

            for trash_item in trashes:
                trash_bbox = trash_item['bbox']
                bottom_center = self.get_bottom_center(trash_bbox)
                if self.is_point_inside_bbox(bottom_center, bin_bbox):
                    trash_area = self.get_bbox_area(trash_bbox)
                    total_trash_area += trash_area
               

            fill_ratio = total_trash_area / bin_area if bin_area > 0 else 0

            bin_statuses.append({
                'bin_label': bin_item['label'],
                'fill_ratio': round(fill_ratio, 3),
                'is_overfilled': fill_ratio > fill_threshold
            })

   
        for trash_item in trashes:
            bottom_center = self.get_bottom_center(trash_item['bbox'])

            # Флаг, что trash вошёл хотя бы в один бак
            is_inside_any_bin = False

            for bin_item in bins:
                bin_bbox = bin_item['bbox']
                if not self.is_point_outside_bbox(bottom_center, bin_bbox):
                    # Точка находится внутри этого бака
                    is_inside_any_bin = True
                    break  # не нужно проверять остальные баки

            if not is_inside_any_bin:
                outside_trash.append({
                    'trash_label': trash_item['label'],
                    'bottom_center': bottom_center,
                    'related_bin': None  # мусор не относится ни к одному баку
                })

       
        return {"bin_statuses": bin_statuses,"outside_trash": outside_trash}

    def predict(self, image_path: str) -> List[Dict[str, Any]]:
        """
        Process an image with YOLO and return detection results
        """
        # Clean previous results to ensure consistent output directory
        DETECT_SUBDIR = RESULTS_DIR / "detect"
        if DETECT_SUBDIR.exists():
            shutil.rmtree(DETECT_SUBDIR)
        
       
        # Run inference
        results = self.model(image_path, save=True, project=str(RESULTS_DIR), name="detect")

        # Process and format results
        detections = []
        class_counters = {}  # Счётчики для каждого класса

        # Get the first result (assuming single image input)
        result = results[0]

        # Extract boxes, confidence scores, and class IDs
        boxes = result.boxes

        # Get original image dimensions
        img = Image.open(image_path)
        orig_width, orig_height = img.size

        # Convert each detection to our output format
        for i, box in enumerate(boxes):
            # Get coordinates (normalized format)
            x1, y1, x2, y2 = box.xyxy[0].tolist()  # xyxy format (x1, y1, x2, y2)

            # Get class and confidence
            cls_id = int(box.cls[0].item())
            conf = float(box.conf[0].item())
            cls_name = result.names[cls_id]
            
            # Увеличиваем счётчик для данного класса
            if cls_name not in class_counters:
                class_counters[cls_name] = 1
            else:
                class_counters[cls_name] += 1

            indexed_label = f"{cls_name} {class_counters[cls_name]}"
            
            detections.append({
                "class": cls_name,                
                "label": indexed_label,
                "confidence": round(conf, 3),
                "bbox": [int(x1), int(y1), int(x2), int(y2)]
            })

        # Get path to the saved result image
        result_path = None
        for file in os.listdir(RESULTS_DIR / "detect"):
            if file.endswith(".jpg") or file.endswith(".png"):
                result_path = str(RESULTS_DIR / "detect" / file)
                # In a real app, you might want to rename and organize these files
                break


        evaluation_result = self.evaluate_bin_fill(detections)
        return {
            "detections": detections,
            "result_image_path": result_path,
            "original_size": [orig_width, orig_height],
            "bin_statuses": evaluation_result["bin_statuses"],
            "outside_trash": evaluation_result["outside_trash"]
        }

# Initialize the model
try:
    model = YOLODetectionModel(str(MODEL_PATH))
except Exception as e:
    print(f"Warning: Could not initialize model: {e}")
    print("The API will start, but the /detect endpoint will fail until a valid model is provided.")
    model = None

# Mount the results directory to serve detection images
app.mount("/results", StaticFiles(directory=str(RESULTS_DIR)), name="results")

@app.get("/")
def read_root():
    return {"message": "YOLO Detection API is running"}

@app.post("/detect/")
async def detect_image(file: UploadFile = File(...)):
    """
    Upload an image and get YOLO detection results.
    """
    # Check if model is initialized
    if model is None:
        raise HTTPException(status_code=500, detail="Model not initialized. Please check server logs.")

    # Validate file is an image
    if not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="File must be an image")

    try:
        # Generate a unique filename
        file_extension = os.path.splitext(file.filename)[1]
        unique_filename = f"{uuid.uuid4()}{file_extension}"
        file_path = UPLOAD_DIR / unique_filename

        # Save the uploaded file
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        # Process the image with the model
        results = model.predict(str(file_path))
        
        # Добавим логику: если найдены шины — формируем сообщение
        classes = [d["class"] for d in results["detections"]]
        if "tires" in classes:
            results["message_tires_detected"] = "На изображении обнаружены автомобильные покрышки. Покрышки относятся к отходам класса опасности 4! Их нельзя выбрасывать на полигоны ТКО!"
            
        

        

        # Make the result image path relative for frontend use
        if results["result_image_path"]:
            # Extract the relative path from results directory
            relative_path = os.path.relpath(results["result_image_path"], start=str(RESULTS_DIR))
            results["result_image_url"] = f"/results/{relative_path}"

        return {
            "filename": file.filename,
            "content_type": file.content_type,
            "original_size": results["original_size"],
            "detections": results["detections"],
            "result_image_url": results.get("result_image_url"),
            "messages": {
                "tires_warning": results.get("message_tires_detected"),
                "bin_statuses": results.get("bin_statuses"),
                "outside_trash": results.get("outside_trash")
            }
        }


    except Exception as e:
        # If any error occurs, make sure we still try to delete the file
        if 'file_path' in locals() and os.path.exists(file_path):
            os.remove(file_path)
        raise HTTPException(status_code=500, detail=f"An error occurred: {str(e)}")

@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "model_loaded": model is not None}

@app.get("/model-info")
def model_info():
    """Get information about the loaded model"""
    if model is None:
        return {"status": "not_loaded", "path": str(MODEL_PATH)}

    return {
        "status": "loaded",
        "path": str(MODEL_PATH),
        "type": "YOLO",
        "class_names": model.model.names if hasattr(model.model, "names") else None
    }

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)